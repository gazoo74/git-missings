#!/bin/bash
#
# Copyright (c) 2017 Gaël PORTAY <gael.portay@savoirfairelinux.com>
#
# This program is free software: you can redistribute it and/or modify
# the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3.
#

set -e
set -o pipefail

cleanup() {
	local rc="$?"
	if [ "$rc" -ne 0 ]; then
		echo "$next" >.git/patch-apply/next
	else
		rm -rf .git/patch-apply/
	fi

	trap - 0
}
log() {
	$QUIET || echo "$*" >&2
}

fatal() {
	echo "fatal: $*" >&2
	exit 1
}

get_patchname() {
	local index
	index="$(printf "%04i" "$1")"
	sed -n .git/patch-apply/todo \
	    -e "$1p"
}

extract_commit_msg() {
	sed -e '/^diff /,$d' \
	    -e '/^--- /,$d' \
	    -e '/^+++ /,$d' \
	    "$1"
}

filename_to_commit_msg() {
	echo "$*" | \
	sed -e 's,^.*/,,' \
	    -e 's,^[0-9]*[_-],,' \
	    -e 's,\.patch,,' \
	    -e 's,[_-], ,g'
}

index_to_filename() {
	sed -n .git/patch-apply/todo \
	    -e "$1p"
}

commit_message() {
	local info filename

	index="$(printf "%04i" "$1")"
	info="$(extract_commit_msg ".git/patch-apply/$1")"
	if [ -z "$info" ]; then
		filename="$(index_to_filename "$1")"
		info="$(filename_to_commit_msg "$filename")"
	fi

	echo "$info"
}

get_patched_files() {
	# patching file path/to/file
	sed -n '/^patching file/s,patching file,,p' \
	    .git/patch-apply/applying
}

get_reject_files() {
	# x out of x hunk FAILED -- saving rejects to file patch/to/file.rej
	sed -n '/[0-9]* out of [0-9]* hunks FAILED/s,.* -- saving rejects to file ,,p' \
	    .git/patch-apply/applying
}

get_unpatched_files() {
	# can't find file to patch at input line xx
	# Perhaps you used the wrong -p or --strip option?
	# The text leading up to this was:
	# --------------------------
	# |--- a/path/to/file
	# |+++ b/path/to/file
	# --------------------------
	# File to patch: 
	# Skip this patch? [y] 
	# Skipping patch.
	# 2 out of 2 hunks ignored
	sed -n '/^|--- a\//s,^|--- a/,,p' \
	    .git/patch-apply/applying
}

get_artifacts_files() {
	get_reject_files
	get_unpatched_files
}

get_all_artifacts_files() {
	get_reject_files | \
	while read -r rej; do
		orig="${rej%*.rej}"
		echo "$rej"
		echo "$orig"
	done
	get_unpatched_files | \
	while read -r f; do
		echo "$f.rej"
	done
}

check_for_rej_files() {
	get_reject_files | \
	while read -r rej; do
		if [ -e "$rej" ]; then
			echo "Remaining reject artifact $rej!" >&2
			exit 1
		fi
	done
}

check_for_orig_files() {
	get_reject_files | \
	while read -r rej; do
		orig="${rej%*.rej}.orig"
		if [ -e "$orig" ]; then
			echo "Remaining original artifact $orig!" >&2
			exit 1
		fi
	done
}

check_for_unpatched_files() {
	get_unpatched_files | \
	while read -r f; do
		if [ -e "$f.rej" ]; then
			echo "Remaining unpatched artifact $f.rej!" >&2
			exit 1
		fi
	done
}

check_for_artifacts() {
	check_for_rej_files
	check_for_orig_files
	check_for_unpatched_files
}

old_check_for_unpatched_files() {
	get_unpatched_files | \
	while read -r f; do
		if [ -e "$f" ]; then
			sed -n "\:--- a/$f:,/--- a/p" .git/patch-apply/patch
			echo "Missing artifact $f!" >&2
		fi
	done
}

add_patched_files_to_index() {
	get_patched_files | \
	while read -r f; do
		git add "$f"
	done
}

saving_unpatched_files_to_rej() {
	get_unpatched_files | \
	while read -r f; do
		mkdir -p "${f%/*}"
		sed -n "\:--- a/$f:,/--- a/p" \
		    .git/patch-apply/patch \
		    >"$f.rej"

		sed -n '/^[0-9]* out of [0-9]* hunks ignored/'"s,$, -- saving rejects to file $f.rej,p" \
		    .git/patch-apply/applying
	done
}

remove_artifacts() {
	get_artifacts_files | xargs rm -f
}

remove_all_artifacts() {
	get_all_artifacts_files | xargs rm -f
}

next() {
	next="$((next + 1))"
	echo "$next" >.git/patch-apply/next
	rm -f .git/patch-apply/patch .git/patch-apply/info .git/patch-apply/applying
}

apply() {
	local info index filename

	# Try to apply mailbox first
	# shellcheck disable=SC2086
	if git am $AMOPTS "$1"; then
		return
	fi

	# Applying mailbox failed
	# Make sure there is no apply-mbox in progress
	if [ -d .git/rebase-apply ]; then
		log "Abort: \"$1\""
		git am --abort
	fi

	# Try to apply diff
	index="$(printf "%04i" "$next")"
	filename="$(index_to_filename "$index")"
	info="$(filename_to_commit_msg "$filename")"
	( echo "$info"
	  echo
	  extract_commit_msg "$1"
        ) >>.git/patch-apply/info

	$QUIET || echo -e "\e[31;1mApplying: $info\e[0m"
	# shellcheck disable=SC2086
	if patch $PATCHOPTS -t -p1 -i "$1" | tee .git/patch-apply/applying; then
		add_patched_files_to_index

		git commit $COMMITOPTS --message "$info"
		return
	fi

	# Neither git am nor patch succeed
	cp "$1" .git/patch-apply/patch
	echo "$info" >.git/patch-apply/info
	add_patched_files_to_index
	saving_unpatched_files_to_rej

	cat <<EOF
The copy of the patch that failed is found in: .git/patch-apply/patch"
When you have resolved this problem, run "git ad --continue".
If you prefer to skip this patch, run "git ad --skip" instead.
To restore the original branch and stop patching, run "git ad --abort".
EOF
	exit 1
}

status() {
	local index last
	index="$(cat .git/patch-apply/next)"
	last="$(cat .git/patch-apply/last)"

	# Print current patch
	if [ -f .git/patch-apply/patch ]; then
		local patch files
		patch="$(get_patchname "$index")"
		files="$(get_artifacts_files | sed 's/ /, /g')"
		if [ -n "$files" ]; then
			echo -e "\e[33m$index (\e[31;1m$files\e[0;33m)\e[0m $patch"
		else
			echo -e "\e[33m$index\e[0m $patch"
		fi

		sed -e 's,^,    ,' .git/patch-apply/applying
		index="$((index+1))"
	fi

	# Print all others
	while [ "$index" -le "$last" ]; do
		patch="$(get_patchname "$index")"
		echo -e "\e[33m$index\e[0m $patch\e[0m"
		index="$((index+1))"
	done
}

continue() {
	# No patch in progress... keep going
	if [ ! -f .git/patch-apply/patch ]; then
		fatal "No ad in progress?"
		return
	fi

	resolved
}

resolved() {
	if [ ! -f .git/patch-apply/patch ]; then
		fatal "No ad in progress?"
	fi

	check_for_artifacts

	# shellcheck disable=SC2086
	git commit $COMMITOPTS --edit --file .git/patch-apply/info
	next
}

skip() {
	remove_all_artifacts
	next
}

abort() {
	# Reset current patchset
	abort_safety="$(cat .git/patch-apply/abort-safety)"
	git clean -xdf
	git reset --hard "$abort_safety"

	# Remove context
	rm -rf .git/patch-apply/
}

check() {
	local patch files
	patch="$(get_patchname "$next")"
	if ! $QUIET; then
		echo -e "\e[1mChecking: $patch\e[0m"
		sed -e 's,^,    ,' .git/patch-apply/applying 
		echo
	fi

	if ! $QUIET; then
		echo -en "\e[1mRejected files:\e[0m "
		get_reject_files
		echo
	fi

	if ! $QUIET; then
		echo -en "\e[1mUnpatched files:\e[0m "
		get_unpatched_files
		echo
	fi

	check_for_artifacts
}

reapply() {
	# shellcheck disable=SC2086
	if ! patch $PATCHOPTS -p1 -i "$1"; then
		add_patched_files_to_index
		saving_unpatched_files_to_rej

		exit 1
	fi

	add_patched_files_to_index
}

reverse() {
	# shellcheck disable=SC2086
	if ! patch $APPLYOPTS -R -p1 -i "$1" | tee .git/patch-apply/reversing; then
		add_patched_files_to_index

		exit 1
	fi

	add_patched_files_to_index
}

init_context() {
	# Setup context
	mkdir .git/patch-apply/

	git rev-parse HEAD >.git/patch-apply/abort-safety

	for patch in "$@"; do
		next="$((next+1))"
		index="$(printf "%04i" "$next")"
		cp "$patch" ".git/patch-apply/$index"
		echo "${patch##*/}"
	done >.git/patch-apply/todo

	last="$next"
	echo "$last" >.git/patch-apply/last

	next="1"
	echo "$next" >.git/patch-apply/next

	cat <<EOF >.git/patch-apply/author-script
GIT_AUTHOR_NAME='$GIT_AUTHOR_NAME'
GIT_AUTHOR_EMAIL='$GIT_AUTHOR_EMAIL'
GIT_AUTHOR_DATE='$GIT_AUTHOR_DATE'
EOF

	if $SIGN; then
		echo "1" >.git/patch-apply/sign
	fi

	if $THREEWAY; then
		echo "1" >.git/patch-apply/threeway
	fi

	if $QUIET; then
		echo "1" >.git/patch-apply/quiet
	fi
}

load_context() {
	next="$(cat .git/patch-apply/next)"
	last="$(cat .git/patch-apply/last)"

	if [ -f .git/patch-apply/sign ]; then
		SIGN="true"
	fi

	if [ -f .git/patch-apply/threeway ]; then
		THREEWAY="true"
	fi

	if [ -f .git/patch-apply/quiet ]; then
		QUIET="true"
	fi
}

usage() {
	cat <<EOF
usage: git ad [<options>] (<mbox> | <diff>)...
   or: git ad (--continue | --skip | --abort)

    -3, --3way            allow fall back on 3way merging if needed
    -q, --quiet           be quiet
    -s, --signoff         add a Signed-off-by line to the commit message
EOF
}

AMOPTS=
COMMITOPTS=
ACTION=
THREEWAY="false"
QUIET="false"
SIGN="false"
while [ $# -ne 0 ]; do
	if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
		usage
		exit 0
	elif [ "$1" = "-3" ] || [ "$1" = "--3way" ]; then
		THREEWAY="false"
	elif [ "$1" = "-q" ] || [ "$1" = "--quiet" ]; then
		QUIET="true"
	elif [ "$1" = "-s" ] || [ "$1" = "--signoff" ]; then
		SIGN="true"
	elif [ "$1" = "--continue" ]; then
		ACTION="continue"
		break
	elif [ "$1" = "--skip" ]; then
		ACTION="skip"
		break
	elif [ "$1" = "--abort" ]; then
		ACTION="abort"
		break
	elif [ "$1" = "--resolved" ]; then
		ACTION="resolved"
		break
	elif [ "$1" = "--reapply" ]; then
		ACTION="reapply"
		break
	elif [ "$1" = "--reverse" ]; then
		ACTION="reverse"
		break
	elif [ "$1" = "--check" ]; then
		ACTION="check"
		break
	elif [ "$1" = "--" ]; then
		shift
		break
	else
		break
	fi
	shift
done

# Hidden status feature
if [ -z "$ACTION" ] && [ "$#" -eq 0 ] && [ -d .git/patch-apply ]; then
	# GIT_PAGER
	#     This environment variable overrides $PAGER. If it is set to an
	#     empty string or to the value "cat", Git will not launch a pager.
	#     See also the core.pager option in git-config(1).
	if env | grep GIT_PAGER; then
		PAGER="$GIT_PAGER"
	fi

	# core.pager
	#
	# This setting determines which pager is used when Git pages output such
	# as log and diff. You can set it to more or to your favorite pager (by
	# default, it’s less), or you can turn it off by setting it to a blank
	# string:
	#
	# $ git config --global core.pager ''
	#
	# If you run that, Git will page the entire output of all commands, no
	# matter how long they are.
	if ! env | grep PAGER; then
		PAGER="$(git config --global core.pager || echo less)"
	fi
	status | LESS="$LESS -rS" ${PAGER:-cat}
	exit
fi

# First form [(<mbox> | <diff>)...]
if [ -z "$ACTION" ]; then
	if [ "$#" -eq 0 ]; then
		usage >&2
		fatal "Too few arguments!"
	fi

	# Make sure there is no apply-mbox in progress
	for dir in .git/rebase-apply .git/patch-apply; do
		if [ -d "$dir" ]; then
			fatal "previous rebase directory $dir still exists but patch given."
		fi
	done

for patch in "$@"; do
	if [ -d "$patch" ]; then
		fatal "$patch is not a patch file."
	fi
done

	init_context "$@"
# Second form (--continue | --skip | --abort)
else
	if [ ! -d .git/patch-apply ]; then
		fatal "Resolve operation not in progress, we are not resuming."
	fi

	load_context
fi

if $THREEWAY; then
	AMOPTS+=" --3way"
	PATCHOPTS+=" --merge"
fi

if $QUIET; then
	AMOPTS+=" --quiet"
fi

if $SIGN; then
	AMOPTS+=" --sign"
	COMMITOPTS+=" --sign"
fi

# shellcheck disable=SC1091
. .git/patch-apply/author-script

# Second form (--continue | --skip | --abort)
case "$ACTION" in
continue|skip)
	"$ACTION"
	;;
abort|resolved)
	"$ACTION"
	exit
	;;
check)
	check
	exit
	;;
reapply|reverse)
	"$ACTION" .git/patch-apply/patch
	exit
	;;
esac

trap "cleanup" 0
while [ "$next" -le "$last" ]; do
	patch="$(printf "%04i" "$next")"
	apply ".git/patch-apply/$patch"
	next
done

rm -rf .git/patch-apply
