#!/bin/bash
#
# Copyright (c) 2017-2018 GaÃ«l PORTAY
#
# SPDX-License-Identifier: GPL-3.0
#

set -e
set -o pipefail

log() {
	$QUIET || echo "$*" >&2
}

fatal() {
	echo "fatal: $*" >&2
	exit 1
}

oops() {
	local abort_safety
	local hint

	trap - 0

	hint="Use 'git patch --quit' to abort and keep HEAD where it is"
	if abort_safety="$(cat .git/patch-apply/abort-safety 2>/dev/null)"; then
		hint+="\n      or 'git reset --hard $abort_safety' to restore the original branch and abort the patching operation"
	fi
	hint "$hint"
	
	fatal "${*:-Oops!}"
}

hint() {
	echo -e "\e[33mhint: $*\e[0m" >&2
}

hint_and_exit() {
	hint "${*:-Use 'git patch --show-current-patch' to see the failed patch}"
	cat <<EOF
When you have resolved this problem, run "git patch --continue".
If you prefer to skip this patch, run "git patch --skip" instead.
To restore the original branch and stop patching, run "git patch --abort".
EOF
	exit 1
}

extract_mailbox_header() {
	sed -e '/^$/,$d' \
	       "$1"
}

extract_mailbox_body() {
	sed -e '1,/^$/d' \
	       "$1"
}

extract_mailbox_info() {
	extract_mailbox_header "$1" |
	sed -e '/From: /s,From: \(.*\) <\(.*\)>,Author: \1\nEmail: \2,p' \
	    -e '/Subject: /s,\[PATCH\( [0-9]\+/[0-9]\+\)\?\] ,,p' \
	    -e '/Date: /p' \
	    -n
	echo
}

extract_mailbox_author_script() {
	extract_mailbox_header "$1" |
	sed -e '/From: /s,From: \(.*\) <\(.*\)>,GIT_AUTHOR_NAME="\1"\nGIT_AUTHOR_EMAIL="\2",p' \
	    -e '/Date: /s,Date: \(.*\),GIT_AUTHOR_DATE="\1",p' \
	    -n
}

extract_mailbox_subject() {
	sed -e '/Subject: /s,Subject: ,,p' \
	    -n "$1"
}

extract_mailbox_commit_message() {
	extract_mailbox_body "$1" | \
	sed -e '/^---$/,$d'
}

extract_mailbox_patch() {
	extract_mailbox_body "$1" | \
	sed -e '/^---/,$p' \
	    -n
}

extract_diff_commit_message() {
	sed -e '/^diff /,$d' \
	    -e '/^--- /,$d' \
	    -e '/^+++ /,$d' \
	       "$1"
}

sanitized_mailbox_subject() {
	# shellcheck disable=SC2001
	echo "$*" | \
	sed -e 's,\[PATCH\( [0-9]\+/[0-9]\+\)\?\] ,,'
}

sanitized_diff_commit_message() {
	echo "$*" | \
	sed -e 's,^.*/,,' \
	    -e 's,^[0-9]*[_-],,' \
	    -e 's,\.patch,,' \
	    -e 's,[_-], ,g'
}

index_to_filename() {
	sed -e "$1p" \
	    -n .git/patch-apply/todo
}

get_patched_files() {
	# Applied patch path/to/file cleanly.
	sed -e '/^Applied patch /s,Applied patch \(.*\) cleanly.$,\1,p' \
	    -n .git/patch-apply/applying
}

get_reject_files() {
	# Applying patch path/to/file with x reject[s]...
	sed -e '/Applying patch /s,Applying patch \(.*\) with [0-9]* rejects\?...$,\1.rej,p' \
	    -n .git/patch-apply/applying
}

get_unpatched_files() {
	# error: path/to/file: does not [exist in|match] index
	sed -e '/error: /s,^error: \(.*\): does not \(exist in\|match\) index$,\1,p' \
	    -n .git/patch-apply/applying
}

get_unpatched_rejects() {
	get_unpatched_files | \
	while read -r f; do
		echo "$f.rej"
	done
}

get_all_artifacts_files() {
	get_reject_files
	get_unpatched_rejects
}

echo_checking_patch_and_reject() {
	echo "Checking patch $1"
	sed -e "/^Checking patch ${1//\//\\/}/,/^\(Checking patch \|$\)/{//d;p}" \
	    -n .git/patch-apply/applying
	cat "$1.rej"
}

check_for_rej_files() {
	get_reject_files | \
	while read -r rej; do
		f="${rej%*.rej}"
		if [ -e "$rej" ]; then
			echo_checking_patch_and_reject "$f"
			if check_for_diff_file "$f"; then
				hint "Use 'rm -f $rej && git patch --continue' to remove the reject and continue"
				echo "The conflict looks to be resolved!" >&2
				exit 1
			fi

			echo "Remaining reject artifact $rej!" >&2
			echo "Resolve the conflict first and remove the file then." >&2
			hint_and_exit "Use 'git patch --show-current-patch' to see the failed patch"
		fi
	done
}

check_for_unpatched_files() {
	get_unpatched_files | \
	while read -r f; do
		rej="$f.rej"
		if [ -e "$rej" ]; then
			echo_checking_patch_and_reject "$f"
			if check_for_diff_file "$f"; then
				hint "Use 'rm -f $rej && git patch --continue' to remove the reject and continue"
				echo "The conflict looks to be resolved!" >&2
				exit 1
			fi

			echo "Remaining unpatched artifact $rej!" >&2
			echo "Resolve the conflict first and remove the file then." >&2
			hint_and_exit "Use 'git patch --show-current-patch' to see the failed patch"
		fi
	done
}

check_for_artifacts() {
	check_for_rej_files
	check_for_unpatched_files
}

check_for_diff() {
	status_patch_changes_only |
	diff -ud --label "patch" --label "cached" --color \
	     - <(status_cached_changes_only)
}

check_for_diff_file() {
	status_patch_file_changes_only "$@" |
	diff -ud --label "patch" --label "cached" --color \
	     - <(status_cached_file_changes_only "$@")
}

add_patched_files_to_index() {
	get_patched_files | \
	while read -r f; do
		git add "$f"
	done
}

saving_unpatched_files_to_rej() {
	get_unpatched_files | \
	while read -r f; do
		mkdir -p "${f%/*}"
		sed -e "\:--- a/$f:,/--- a/p" \
		    -n .git/patch-apply/patch \
		    >"$f.rej"
	done
}

remove_all_artifacts() {
	get_all_artifacts_files | xargs rm -f
}

next() {
	next="$((next + 1))"
	echo "$next" >.git/patch-apply/next
	rm -f .git/patch-apply/patch \
	      .git/patch-apply/final-commit \
	      .git/patch-apply/applying
}

commit() {
	local GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL GIT_AUTHOR_DATE

	# shellcheck disable=SC1091
	. .git/patch-apply/author-script

	# shellcheck disable=SC2086
	GIT_AUTHOR_NAME="${GIT_AUTHOR_NAME:-$(git config --get user.name)}" \
	GIT_AUTHOR_EMAIL="${GIT_AUTHOR_EMAIL:-$(git config --get user.email)}" \
	GIT_AUTHOR_DATE="${GIT_AUTHOR_DATE:-$(date --rfc-email)}" \
	git commit $COMMITOPTS --file .git/patch-apply/final-commit "$@"
}

edit_commit() {
	if [ -t 0 ]; then
		set -- --edit "$@"
	fi

	commit "$@"
}

status_cached() {
	git diff --cached | \
	sed -e '/^diff /d' \
	    -e '/^index /d'
}

status_cached_changes_only() {
	status_cached | \
	sed -e '/^\(@@\| \)/d'
}

status_cached_file() {
	status_cached | \
	sed -e "/^--- .\\+\\/${1//\//\\\/}/,/^\(--- .*\|\)$/{//d;/^+++/d;p}" \
	    -n
}

status_cached_file_changes_only() {
	status_cached_file "$@" | \
	sed -e '/^\(@@\| \)/d'
}

status_patch() {
	sed -e '1,/^diff/d' \
	    -e '/^-- $/,$d' \
	    -e '/^diff /d' \
	    -e '/^index /d' \
	       .git/patch-apply/patch
}

status_patch_changes_only() {
	status_patch | \
	sed -e '/^\(@@\| \)/d'
}

status_patch_file() {
	status_patch | \
	sed -e "/^--- .\\+\\/${1//\//\\\/}/,/^\(--- .*\|\)$/{//d;/^+++/d;p}" \
	    -n
}

status_patch_file_changes_only() {
	status_patch_file "$@" | \
	sed -e '/^\(@@\| \)/d'
}

resolve_unpatched() {
	for rej in $(get_unpatched_rejects); do
		[ -e "$rej" ] || continue

		oldfile="${rej%*.rej}"
		while read -erp "File to patch for $rej [$oldfile]: " patchfile; do
			[ -n "$patchfile" ] || patchfile="$oldfile"
			[ -n "$patchfile" ] || continue
			if [ ! -e "$patchfile" ]; then
				echo "Error: $patchfile: No such file!" >&2
				continue
			fi

			# Try applying reject in a treeway merge...
			if sed -e "s,$oldfile,$patchfile," "$rej" | \
			   git apply - -3; then
				git add "$patchfile"
				rm -f "$rej"
				break
			fi

			# Try applying and save rejects...
			if sed -e "s,$oldfile,$patchfile," "$rej" | \
			   git apply - --reject; then
				git add "$patchfile"
				rm -f "$rej"
				break
			fi

			# New rejects found!
			if [ "$patchfile.rej" != "$rej" ] &&
			   [ -e "$patchfile.rej" ]; then
				git add "$patchfile"
				rm -f "$rej"
				ln -sf "$(realpath "$patchfile.rej")" "$rej"
			fi

			return 1
		done
	done
}

resolve_rejected() {
	for rej in $(get_reject_files); do
		[ -e "$rej" ] || continue

		local patchfile
		patchfile="${rej%*.rej}"

		# Try applying reject in a treeway merge...
		if sed -e "/^diff a/a--- a/$patchfile\n+++ b/$patchfile" "$rej" | \
		   git apply - -3; then
			git add "$patchfile"
			rm -f "$rej"
			break
		fi

		# Try applying and save rejects...
		if sed -e "/^diff a/a--- a/$patchfile\n+++ b/$patchfile" "$rej" | \
		   git apply - --reject; then
			git add "$patchfile"
			rm -f "$rej"
			break
		fi

		return 1
	done
}

autoresolve() {
	# Reduce context amount of lines
	if ! resolve_rejected -C2 --recount ||
	   ! resolve_rejected -C1 --recount; then
		return 1
	fi

	# Prompt for unpatch files
	if ! [ -t 0 ] ||
	   ! resolve_unpatched; then
		return 1
	fi

	return 0
}

patch() {
	local msg index filename

	# Try to apply mailbox first
	# shellcheck disable=SC2086
	if git am $AMOPTS "$1"; then
		return
	fi

	# Applying mailbox failed
	# Make sure there is no apply-mbox in progress
	if [ -d .git/rebase-apply ]; then
		log "Abort: \"$1\""
		git am --abort
	fi

	# Try to apply patch
	index="$(printf "%04i" "$next")"
	filename="$(index_to_filename "$index")"
	subject="$(extract_mailbox_subject "$1")"
	if [ -n "$subject" ]; then
		# patch is in mailbox format
		msg="$(sanitized_mailbox_subject "$subject")"
		extract_mailbox_commit_message "$1" >.git/patch-apply/msg
		extract_mailbox_patch "$1" >.git/patch-apply/patch
		extract_mailbox_info "$1" >.git/patch-apply/info
		extract_mailbox_author_script "$1" >.git/patch-apply/author-script
	else
		# patch is a diff format
		msg="$(sanitized_diff_commit_message "$filename")"
		extract_diff_commit_message "$1" >.git/patch-apply/msg
		cp "$1" .git/patch-apply/patch
		cat <<EOF >.git/patch-apply/author-script
GIT_AUTHOR_NAME='${GIT_AUTHOR_NAME:-$(git config --get user.name)}'
GIT_AUTHOR_EMAIL='${GIT_AUTHOR_EMAIL:-$(git config --get user.email)}'
GIT_AUTHOR_DATE='${GIT_AUTHOR_DATE:-$(date --rfc-email)}'
EOF
	fi

	# final-commit contains the commit message
	cat - .git/patch-apply/msg <<EOF >.git/patch-apply/final-commit
$msg

EOF

	$QUIET || echo "Applying: $msg"
	# shellcheck disable=SC2086
	if git apply $APPLYOPTS "$1" 2>&1 | \
	   tee .git/patch-apply/applying >&2; then
		commit
		return
	fi

	# Neither am nor apply succeed
	add_patched_files_to_index
	saving_unpatched_files_to_rej

	# Try to auto-resolve
	if $AUTORESOLVE && autoresolve; then
		edit_commit
		return
	fi

	hint_and_exit "Use 'git patch --show-current-patch' to see the failed patch"
}

action_continue() {
	# No patch in progress... keep going
	if [ ! -f .git/patch-apply/patch ]; then
		fatal "No apply in progress?"
		return
	fi

	$QUIET || echo "Applying: $(head -n1 .git/patch-apply/final-commit)"
	check_for_artifacts
	if ! check_for_diff; then
		echo "Warning: changes are not rigorously identical!" >&2
	fi

	edit_commit
	next
}

action_skip() {
	remove_all_artifacts
	next
}

action_abort() {
	# Reset current patchset
	trap 'oops "The impossible happened! Cannot recover :("' 0
	abort_safety="$(cat .git/patch-apply/abort-safety)"
	remove_all_artifacts
	git reset --hard "$abort_safety"
	trap - 0

	# Remove context
	action_quit
}

action_quit() {
	rm -rf .git/patch-apply/
}

action_status() {
	status_patch |
	diff -ud --label "patch" --label "cached" --color \
	     - <(status_cached) || true
}

action_resolve() {
	autoresolve
}

action_show-current-patch() {
	cat .git/patch-apply/patch
}

usage() {
	cat <<EOF
usage: git patch [<options>] [(<mbox> | <unified>)...]
   or: git patch (--continue | --skip | --abort | --quit | --status | --resolve | --show-current-patch)

        --autoresolve     try to auto-resolve rejects
        --continue        continue applying patches after resolving a conflict
        --skip            skip the current patch
        --abort           restore the original branch and abort the patching operation.
        --quit            abort the patching operation but keep HEAD where it is.
        --status          compare original patch to patching operation
        --resolve         try to automatically resolve rejected hunks
        --show-current-patch
                          show the patch being applied.
    -s, --signoff         add a Signed-off-by line to the commit message
    -3, --3way            attempt three-way merge if a patch does not apply
        --no-utf8         no recode into utf8
    -k, --keep            pass -k flag to git-mailinfo
    -m, --message-id      pass -m flag to git-mailinfo
    -c, --scissors        strip everything before a scissors line
    -q, --quiet           be quiet
EOF
}

t() {
	true
}

f() {
	false
}

AMOPTS=
APPLYOPTS=
COMMITOPTS=
ACTION=
AUTORESOLVE="f"
SIGN="f"
THREEWAY="f"
UTF8="t"
KEEP="f"
MESSAGEID="f"
SCISSORS="f"
QUIET="f"
while [ $# -ne 0 ]; do
	if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
		usage
		exit 0
	elif [ "$1" = "--autoresolve" ]; then
		AUTORESOLVE="t"
	elif [ "$1" = "-s" ] || [ "$1" = "--signoff" ]; then
		SIGN="t"
	elif [ "$1" = "-3" ] || [ "$1" = "--3way" ]; then
		THREEWAY="t"
	elif [ "$1" = "--no-utf8" ]; then
		UTF8="f"
	elif [ "$1" = "-k" ] || [ "$1" = "--keep" ]; then
		KEEP="t"
	elif [ "$1" = "-m" ] || [ "$1" = "--message-id" ]; then
		MESSAGEID="t"
	elif [ "$1" = "-c" ] || [ "$1" = "--scissors" ]; then
		SCISSORS="t"
	elif [ "$1" = "-q" ] || [ "$1" = "--quiet" ]; then
		QUIET="t"
	elif [ "$1" = "--continue" ]; then
		ACTION="continue"
		break
	elif [ "$1" = "--skip" ]; then
		ACTION="skip"
		break
	elif [ "$1" = "--abort" ]; then
		ACTION="abort"
		break
	elif [ "$1" = "--quit" ]; then
		ACTION="quit"
		break
	elif [ "$1" = "--status" ]; then
		ACTION="status"
		break
	elif [ "$1" = "--resolve" ]; then
		ACTION="resolve"
		break
	elif [ "$1" = "--show-current-patch" ]; then
		ACTION="show-current-patch"
		break
	elif [ "$1" = "--" ]; then
		shift
		break
	else
		break
	fi
	shift
done

# First form [(<mbox> | <unified>)...]
if [ -z "$ACTION" ]; then
	# Make sure there is no apply-mbox in progress
	for dir in .git/rebase-apply .git/patch-apply; do
		if [ -d "$dir" ]; then
			fatal "previous rebase directory $dir still exists but patch given."
		fi
	done

	# Setup context
	mkdir .git/patch-apply/

	git rev-parse HEAD >.git/patch-apply/abort-safety

	if [ "$#" -eq 0 ]; then
		next="$((next+1))"
		index="$(printf "%04i" "$next")"
		cat - >".git/patch-apply/$index"
		echo "stdin"
	else
		for patch in "$@"; do
			next="$((next+1))"
			index="$(printf "%04i" "$next")"
			cp "$patch" ".git/patch-apply/$index"
			echo "${patch##*/}"
		done
	fi >.git/patch-apply/todo

	last="$next"
	echo "$last" >.git/patch-apply/last

	next="1"
	echo "$next" >.git/patch-apply/next

	echo "$AUTORESOLVE" >.git/patch-apply/autoresolve
	echo "$SIGN" >.git/patch-apply/sign
	echo "$THREEWAY" >.git/patch-apply/threeway
	echo "$UTF8" >.git/patch-apply/utf8
	echo "$KEEP" >.git/patch-apply/keep
	echo "$MESSAGEID" >.git/patch-apply/messageid
	echo "$SCISSORS" >.git/patch-apply/scissors
	echo "$QUIET" >.git/patch-apply/quiet
# Second form (--continue | --skip | --abort | --quit)
else
	if [ ! -d .git/patch-apply ]; then
		fatal "Resolve operation not in progress, we are not resuming."
	fi

	if [ "$ACTION" != "quit" ]; then
		trap 'oops "The impossible happened! Cannot recover :("' 0
		next="$(cat .git/patch-apply/next)"
		last="$(cat .git/patch-apply/last)"
		trap - 0

		AUTORESOLVE="$(cat .git/patch-apply/autoresolve || echo "f")"
		SIGN="$(cat .git/patch-apply/sign || echo "f")"
		THREEWAY="$(cat .git/patch-apply/threeway || echo "t")"
		UTF8="$(cat .git/patch-apply/utf8 || echo "t")"
		KEEP="$(cat .git/patch-apply/keep || echo "f")"
		MESSAGEID="$(cat .git/patch-apply/messageid || echo "f")"
		SCISSORS="$(cat .git/patch-apply/scissors || echo "f")"
		QUIET="$(cat .git/patch-apply/quiet || echo "f")"
	fi
fi

if $SIGN; then
	AMOPTS+=" --signoff"
	COMMITOPTS+=" --signoff"
fi

if $THREEWAY; then
	AMOPTS+=" --3way"
	APPLYOPTS+=" --3way"
else
	AMOPTS+=" --reject"
	APPLYOPTS+=" --reject --index"
fi

if $UTF8; then
	AMOPTS+=" --utf8"
else
	AMOPTS+=" --no-utf8"
fi

if $QUIET; then
	AMOPTS+=" --quiet"
else
	APPLYOPTS+=" --verbose"
fi

# Second form (--continue | --skip | --abort | --quit | --status | --resolve | --show-current-patch)
case "$ACTION" in
continue|skip)
	"action_$ACTION"
	;;
abort|quit|status|resolve|show-current-patch)
	"action_$ACTION"
	exit
	;;
esac

while [ "$next" -le "$last" ]; do
	patch="$(printf "%04i" "$next")"
	patch ".git/patch-apply/$patch"
	next
done

rm -rf .git/patch-apply
