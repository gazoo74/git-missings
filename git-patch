#!/bin/bash
#
# Copyright (c) 2017-2018 GaÃ«l PORTAY <gael.portay@savoirfairelinux.com>
#
# This program is free software: you can redistribute it and/or modify
# the terms of the GNU General Public License as published by
# the Free Software Foundation, version 3.
#

set -x
set -e
set -o pipefail

# The following function is based on code from:
#
# bash/zsh completion support for core Git.
#
# Copyright (C) 2006,2007 Shawn O. Pearce <spearce@spearce.org>
# Conceptually based on gitcompletion (http://gitweb.hawaga.org.uk/).
# Distributed under the GNU General Public License, version 2.0.
#
# Discovers the path to the git repository taking any '--git-dir=<path>' and
# '-C <path>' options into account and stores it in the $__git_repo_path
# variable.
__git_find_repo_path ()
{
	if [ -n "$__git_repo_path" ]; then
		# we already know where it is
		return
	fi

	if [ -n "${__git_C_args-}" ]; then
		__git_repo_path="$(git "${__git_C_args[@]}" \
			${__git_dir:+--git-dir="$__git_dir"} \
			rev-parse --absolute-git-dir 2>/dev/null)"
	elif [ -n "${__git_dir-}" ]; then
		test -d "$__git_dir" &&
		__git_repo_path="$__git_dir"
	elif [ -n "${GIT_DIR-}" ]; then
		test -d "${GIT_DIR-}" &&
		__git_repo_path="$GIT_DIR"
	elif [ -d .git ]; then
		__git_repo_path=.git
	else
		__git_repo_path="$(git rev-parse --git-dir 2>/dev/null)"
	fi
}

log() {
	$QUIET || echo "$*" >&2
}

fatal() {
	echo "fatal: $*" >&2
	exit 1
}

prompt_yes_no() {
	local resp
	while read -rp"$1 $2? " resp; do
		[ -n "$resp" ] || break

		resp="$(echo "$resp" | sed -e 's/.*/\L&/')"
		case "$resp" in
		y|yes|n|no) break;;
		esac

		echo "Invalid response!" >&2;
		unset resp
	done

	if [ -z "$resp" ]; then
		resp="$(echo "$2" | sed -e 's,^\[\(.*\)/.*\]$,\1,')"
	fi

	resp="$(echo "$resp" | sed -e 's/.*/\L&/')"
	case "$resp" in
	y|yes)	return 0;;
	esac

	return 1
}

extract_mailbox_header() {
	sed -e '/^$/,$d' \
	    "$1"
}

extract_mailbox_body() {
	sed -e '1,/^$/d' \
	    "$1"
}

extract_mailbox_info() {
	extract_mailbox_header "$1" |
	sed -e '/From: /s,From: \(.*\) <\(.*\)>,Author: \1\nEmail: \2,p' \
	    -e '/Subject: /s,\[PATCH\( [0-9]\+/[0-9]\+\)\?\] ,,p' \
	    -e '/Date: /p' \
	    -n
	echo
}

extract_mailbox_author_script() {
	extract_mailbox_header "$1" |
	sed -e '/From: /s,From: \(.*\) <\(.*\)>,GIT_AUTHOR_NAME="\1"\nGIT_AUTHOR_EMAIL="\2",p' \
	    -e '/Date: /s,Date: \(.*\),GIT_AUTHOR_DATE="\1",p' \
	    -n
}

extract_mailbox_subject() {
	sed -n '/Subject: /s,Subject: ,,p' \
	    "$1"
}

extract_mailbox_commit_message() {
	extract_mailbox_body "$1" | \
	sed -e '/^---$/,$d'
}

extract_mailbox_patch() {
	extract_mailbox_body "$1" | \
	sed -n '/^---/,$p'
}

extract_diff_commit_message() {
	sed -e '/^diff /,$d' \
	    -e '/^--- /,$d' \
	    -e '/^+++ /,$d' \
	    "$1"
}

sanitized_mailbox_subject() {
	# shellcheck disable=SC2001
	echo "$*" | \
	sed -e 's,\[PATCH\( [0-9]\+/[0-9]\+\)\?\] ,,'
}

sanitized_diff_commit_message() {
	echo "$*" | \
	sed -e 's,^.*/,,' \
	    -e 's,^[0-9]*[_-],,' \
	    -e 's,\.patch,,' \
	    -e 's,[_-], ,g'
}

index_to_filename() {
	sed -n "$gitapplydir/todo" \
	    -e "$1p"
}

get_patched_files() {
	# Applied patch path/to/file cleanly.
	sed -n '/^Applied patch /s,Applied patch \(.*\) cleanly.$,\1,p' \
	    "$gitapplydir/applying"
}

get_reject_files() {
	# Applying patch path/to/file with x reject[s]...
	sed -n '/Applying patch /s,Applying patch \(.*\) with [0-9]* rejects\?...$,\1.rej,p' \
	    "$gitapplydir/applying"
}

get_unpatched_files() {
	# error: path/to/file: does not exist in index
	sed -n '/error: /s,^error: \(.*\): does not exist in index$,\1,p' \
	    "$gitapplydir/applying"
}

get_unpatched_rejects() {
	get_unpatched_files | \
	while read -r f; do
		echo "$f.rej"
	done
}

get_all_artifacts_files() {
	get_reject_files
	get_unpatched_rejects
}

check_for_rej_files() {
	get_reject_files | \
	while read -r rej; do
		if [ -e "$rej" ]; then
			echo "Remaining reject artifact $rej!" >&2
			exit 1
		fi
	done
}

check_for_unpatched_files() {
	get_unpatched_files | \
	while read -r f; do
		if [ -e "$f.rej" ]; then
			echo "Remaining unpatched artifact $f.rej!" >&2
			exit 1
		fi
	done
}

check_for_artifacts() {
	check_for_rej_files
	check_for_unpatched_files
}

add_patched_files_to_index() {
	get_patched_files | \
	while read -r f; do
		git add "$f"
	done
}

saving_unpatched_files_to_rej() {
	get_unpatched_files | \
	while read -r f; do
		mkdir -p "${f%/*}"
		sed -n "\:--- a/$f:,/--- a/p" \
		    "$gitapplydir/patch" \
		    >"$f.rej"
#
#		sed -n '/^[0-9]* out of [0-9]* hunks ignored/'"s,$, -- saving rejects to file $f.rej,p" \
#		    "$gitapplydir/applying
	done
}

remove_all_artifacts() {
	get_all_artifacts_files | xargs rm -f
}

next() {
	next="$((next + 1))"
	echo "$next" >"$gitapplydir/next"
	rm -f "$gitapplydir/patch" \
	      "$gitapplydir/final-commit" \
	      "$gitapplydir/applying"
}

commit() {
	local GIT_AUTHOR_NAME GIT_AUTHOR_EMAIL GIT_AUTHOR_DATE

	if [ "$(git status --porcelain --untracked-files=no | wc -l)" -eq 0 ]; then
		local msg
		msg="$(head -n1 "$gitapplydir/final-commit")"
		cat <<EOF
Applying: $msg
No changes - did you forget to use 'git add'?
If there is nothing left to stage, chances are that something else
already introduced the same changes; you might want to skip this patch.
When you have resolved this problem, run "git patch --continue".
If you prefer to skip this patch, run "git patch --skip" instead.
To restore the original branch and stop patching, run "git patch --abort".
EOF

		exit 1
	fi

	# shellcheck disable=SC1091
	. "$gitapplydir/author-script"

	# shellcheck disable=SC2086
	GIT_AUTHOR_NAME="${GIT_AUTHOR_NAME:-$(git config --get user.name)}" \
	GIT_AUTHOR_EMAIL="${GIT_AUTHOR_EMAIL:-$(git config --get user.email)}" \
	GIT_AUTHOR_DATE="${GIT_AUTHOR_DATE:-$(date --rfc-email)}" \
	git commit $COMMITOPTS --file "$gitapplydir/final-commit" "$@"
}

edit_commit() {
	if [ -t 0 ]; then
		set -- --edit "$@"
	fi

	commit "$@"
}

status_cached() {
	git diff --cached | sed -e '/^diff /d' -e '/^index /d'
}

status_patch() {
	sed -e '1,/^diff/d' \
	    -e '/^-- $/,$d' \
	    -e '/^diff /d' \
	    -e '/^index /d' \
	    "$gitapplydir/patch"
}

commit_status() {
	action_status | sed -e 's,^,#\t,'
}

diff_tool() {
	local difftool

	if ! difftool="$(git config --get diff.tool)"; then
		return 1
	fi

	"$difftool" "$@" && \
	prompt_yes_no "Does conflicts are successfully merged" "[No/yes]"
}

resolve_unpatched() {
	for rej in $(get_unpatched_rejects); do
		[ -e "$rej" ] || continue

		oldfile="${rej%*.rej}"
		while read -erp "File to patch for $oldfile: " patchfile; do
			[ -n "$patchfile" ] || continue
			if [ ! -e "$patchfile" ]; then
				echo "Error: $patchfile: No such file!" >&2
				continue
			fi

			# Try applying reject in a treeway merge...
			if sed -e "s,$oldfile,$patchfile," "$rej" | \
			   git apply "$@" - -3; then
				git add "$patchfile"
				rm -f "$rej"
				break
			fi

			# Try applying and save rejects...
			if sed -e "s,$oldfile,$patchfile," "$rej" | \
			   git apply "$@" - --reject; then
				git add "$patchfile"
				rm -f "$rej"
				break
			fi

			# New rejects found!
			if [ -e "$patchfile.rej" ]; then
				git add "$patchfile"
				rm -f "$rej"
				ln -sf "$(realpath "$patchfile.rej")" "$rej"
			fi

			# Manually merge
			if [ -t 0 ] && diff_tool "$rej" "$patchfile"; then
				if [ -L "$rej" ]; then
					readlink "$rej" | xargs rm -f
				fi
				git add "$patchfile"
				rm -f "$rej"
				break
			fi

			return 1
		done
	done
}

resolve_rejected() {
	for rej in $(get_reject_files); do
		[ -e "$rej" ] || continue

		local patchfile
		patchfile="${rej%*.rej}"

		# Try applying reject in a treeway merge...
		if sed -e "/^diff a/a--- a/$patchfile\n+++ b/$patchfile" "$rej" | \
		   git apply "$@" - -3; then
			git add "$patchfile"
			rm -f "$rej"
			break
		fi

		# Try applying and save rejects...
		if sed -e "/^diff a/a--- a/$patchfile\n+++ b/$patchfile" "$rej" | \
		   git apply "$@" - --reject; then
			git add "$patchfile"
			rm -f "$rej"
			break
		fi

		# Manually merge
		if [ -t 0 ] && diff_tool "$rej" "$patchfile"; then
			if [ -L "$rej" ]; then
				readlink "$rej" | xargs rm -f
			fi
			git add "$patchfile"
			rm -f "$rej"
			break
		fi

		return 1
	done
}

autoresolve() {
	# Reduce context amount of lines
	if ! resolve_rejected -C2 --recount ||
	   ! resolve_rejected -C1 --recount; then
		return 1
	fi

	# Prompt for unpatch files
	if ! [ -t 0 ] ||
	   ! resolve_unpatched; then
		return 1
	fi

	return 0
}

patch() {
	local msg index filename

	# Try to apply mailbox first
	# shellcheck disable=SC2086
	if git am $AMOPTS "$1" 2>&1; then
		return
	fi

	# Applying mailbox failed
	# Make sure there is no apply-mbox in progress
	if [ -d "$gitdir/rebase-apply" ]; then
		log "Abort: \"$1\""
		git am --abort
	fi

	# Try to apply patch
	index="$(printf "%04i" "$next")"
	filename="$(index_to_filename "$index")"
	subject="$(extract_mailbox_subject "$1")"
	if [ -n "$subject" ]; then
		# patch is in mailbox format
		msg="$(sanitized_mailbox_subject "$subject")"
		extract_mailbox_commit_message "$1" >"$gitapplydir/msg"
		extract_mailbox_patch "$1" >"$gitapplydir/patch"
		extract_mailbox_info "$1" >"$gitapplydir/info"
		extract_mailbox_author_script "$1" >"$gitapplydir/author-script"
	else
		# patch is a diff format
		msg="$(sanitized_diff_commit_message "$filename")"
		extract_diff_commit_message "$1" >"$gitdir/patch-apply/msg"
		cp "$1" "$gitapplydir/patch"
		cat <<EOF >"$gitapplydir/author-script"
GIT_AUTHOR_NAME='${GIT_AUTHOR_NAME:-$(git config --get user.name)}'
GIT_AUTHOR_EMAIL='${GIT_AUTHOR_EMAIL:-$(git config --get user.email)}'
GIT_AUTHOR_DATE='${GIT_AUTHOR_DATE:-$(date --rfc-email)}'
EOF
	fi

	# final-commit contains the commit message
	cat - "$gitapplydir/msg" <<EOF >"$gitapplydir/final-commit"
$msg

EOF

	$QUIET || echo "Applying: $msg"

	# shellcheck disable=SC2086
	if git apply $APPLYOPTS "$1" 2>&1 | \
	   tee "$gitapplydir/applying" >&2; then
		commit
		return
	fi

	# Neither am nor apply succeed
	add_patched_files_to_index
	saving_unpatched_files_to_rej

	# Try to auto-resolve
	if $AUTORESOLVE && autoresolve; then
		edit_commit
		return
	fi

	cat <<EOF
The copy of the patch that failed is found in: "$gitapplydir/patch"
When you have resolved this problem, run "git patch --continue".
If you prefer to skip this patch, run "git patch --skip" instead.
To restore the original branch and stop patching, run "git patch --abort".
EOF
	exit 1
}

action_continue() {
	# No patch in progress... keep going
	if [ ! -f "$gitapplydir/patch" ]; then
		fatal "No apply in progress?"
		return
	fi

	resolved
}

resolved() {
	if [ ! -f "$gitapplydir/patch" ]; then
		fatal "No ad in progress?"
	fi

	check_for_artifacts

	edit_commit
	next
}

action_skip() {
	remove_all_artifacts
	next
}

action_abort() {
	# Reset current patchset
	abort_safety="$(cat "$gitapplydir/abort-safety")"
	git clean -xdf
	git reset --hard "$abort_safety"

	# Remove context
	rm -rf "$gitapplydir/"
}

action_status() {
	status_patch |
	diff -ud --label "patch" --label "cached" --color \
	     - <(status_cached) || true
}

action_resolve() {
	autoresolve
}

usage() {
	cat <<EOF
usage: git patch [<options>] [(<mbox> | <unified>)...]
   or: git patch (--continue | --skip | --abort | --status)
   or: git patch --resolved

        --autoresolve     try to auto-resolve rejects
    -s, --signoff         add a Signed-off-by line to the commit message
    -3, --3way            attempt three-way merge if a patch does not apply
        --no-utf8         no recode into utf8
    -k, --keep            pass -k flag to git-mailinfo
    --keep-non-patch      pass -b flag to git-mailinfo
    --keep-cr             pass --keep-cr flag to git-mailsplit for mbox format
    --no-keep-cr          do not pass --keep-cr flag to git-mailsplit independent of am.keepcr
    -m, --message-id      pass -m flag to git-mailinfo
    -c, --scissors        strip everything before a scissors line
    -q, --quiet           be quiet
EOF
}

__git_find_repo_path
gitdir="$__git_repo_path"
gitapplydir="$gitdir/rebase-apply"

t() {
	true
}

f() {
	false
}

AMOPTS=
APPLYOPTS=
COMMITOPTS=
ACTION=
AUTORESOLVE="f"
SIGN="f"
THREEWAY="f"
UTF8="t"
KEEP="f"
MESSAGEID="f"
SCISSORS="f"
QUIET="f"
while [ $# -ne 0 ]; do
	if [ "$1" = "-h" ] || [ "$1" = "--help" ]; then
		usage
		exit 0
	elif [ "$1" = "--autoresolve" ]; then
		AUTORESOLVE="t"
	elif [ "$1" = "-s" ] || [ "$1" = "--signoff" ]; then
		SIGN="t"
	elif [ "$1" = "-3" ] || [ "$1" = "--3way" ]; then
		THREEWAY="t"
	elif [ "$1" = "-u" ] || [ "$1" = "--utf8" ]; then
		UTF8="t"
	elif [ "$1" = "--no-utf8" ]; then
		UTF8="f"
	elif [ "$1" = "-k" ] || [ "$1" = "--keep" ]; then
		KEEP="t"
	elif [ "$1" = "-m" ] || [ "$1" = "--message-id" ]; then
		MESSAGEID="t"
	elif [ "$1" = "-c" ] || [ "$1" = "--scissors" ]; then
		SCISSORS="t"
	elif [ "$1" = "-q" ] || [ "$1" = "--quiet" ]; then
		QUIET="t"
	elif [ "$1" = "--continue" ]; then
		ACTION="continue"
		break
	elif [ "$1" = "--resolved" ]; then
		ACTION="resolved"
		break
	elif [ "$1" = "--skip" ]; then
		ACTION="skip"
		break
	elif [ "$1" = "--abort" ]; then
		ACTION="abort"
		break
	elif [ "$1" = "--status" ]; then
		ACTION="status"
		break
	elif [ "$1" = "--resolve" ]; then
		ACTION="resolve"
		break
	elif [ "$1" = "--" ]; then
		shift
		break
	else
		break
	fi
	shift
done

# First form [(<mbox> | <unified>)...]
if [ -z "$ACTION" ]; then
	# Make sure there is no apply in progress
	if [ -d "$gitapplydir" ]; then
		fatal "previous rebase directory $gitapplydir still exists but patch given."
	fi

	# Setup context
	mkdir "$gitapplydir/"

	git rev-parse HEAD >"$gitapplydir/abort-safety"

	if [ "$#" -eq 0 ]; then
		next="$((next+1))"
		index="$(printf "%04i" "$next")"
		cat - >"$gitapplydir/$index"
		echo "${patch##*/}"
	else
		for patch in "$@"; do
			next="$((next+1))"
			index="$(printf "%04i" "$next")"
			cp "$patch" "$gitapplydir/$index"
			echo "${patch##*/}"
		done
	fi >"$gitapplydir/todo"

	last="$next"
	echo "$last" >"$gitapplydir/last"

	next="1"
	echo "$next" >"$gitapplydir/next"

	echo "$AUTORESOLVE" >"$gitapplydir/autoresolve"
	echo "$SIGN" >"$gitapplydir/sign"
	echo "$THREEWAY" >"$gitapplydir/threeway"
	echo "$UTF8" >"$gitapplydir/utf8"
	echo "$KEEP" >"$gitapplydir/keep"
	echo "$MESSAGEID" >"$gitapplydir/messageid"
	echo "$SCISSORS" >"$gitapplydir/scissors"
	echo "$QUIET" >"$gitapplydir/quiet"
# Second form (--continue | --skip | --abort)
else
	if [ ! -d "$gitapplydir" ]; then
		fatal "Resolve operation not in progress, we are not resuming."
	fi

	next="$(cat "$gitapplydir/next")"
	last="$(cat "$gitapplydir/last")"

	AUTORESOLVE="$(cat "$gitapplydir/autoresolve" || echo "f")"
	SIGN="$(cat "$gitapplydir/sign" || echo "f")"
	THREEWAY="$(cat "$gitapplydir/threeway" || echo "t")"
	UTF8="$(cat "$gitapplydir/utf8" || echo "t")"
	KEEP="$(cat "$gitapplydir/keep" || echo "f")"
	MESSAGEID="$(cat "$gitapplydir/messageid" || echo "f")"
	SCISSORS="$(cat "$gitapplydir/scissors" || echo "f")"
	QUIET="$(cat "$gitapplydir/quiet" || echo "f")"
fi

if $SIGN; then
	AMOPTS+=" --signoff"
	COMMITOPTS+=" --signoff"
fi

if $THREEWAY; then
	AMOPTS+=" --3way"
	APPLYOPTS+=" --3way"
else
	AMOPTS+=" --reject"
	APPLYOPTS+=" --reject --index"
fi

if $UTF8; then
	AMOPTS+=" --utf8"
else
	AMOPTS+=" --no-utf8"
fi

if $QUIET; then
	AMOPTS+=" --quiet"
else
	APPLYOPTS+=" --verbose"
fi

# Second form (--continue | --skip | --abort | --status | --resolve)
case "$ACTION" in
continue|skip)
	"action_$ACTION"
	;;
abort|status|resolved)
	"action_$ACTION"
	exit
	;;
esac

while [ "$next" -le "$last" ]; do
	patch="$(printf "%04i" "$next")"
	patch "$gitapplydir/$patch"
	next
done

rm -rf "$gitapplydir"
